[
  {
    "title": "Count distinct elements in subarray",
    "topic": "Arrays",
    "difficulty": "Medium",
    "description": "Given an array of integers and a window size k, for each window of size k, count the number of distinct elements. Return an array containing the distinct count for each window.\n\nExample: For array [1, 2, 1, 3, 4] and k=3, windows are [1,2,1] (2 distinct), [2,1,3] (3 distinct), [1,3,4] (3 distinct).",
    "sampleInput": "arr = [1, 2, 1, 3, 4], k = 3",
    "sampleOutput": "[2, 3, 3]",
    "constraints": "1 ≤ n ≤ 10^5\n1 ≤ k ≤ n\n-10^9 ≤ arr[i] ≤ 10^9",
    "testCases": [
      {
        "input": "arr = [1, 2, 1, 3, 4], k = 3",
        "expectedOutput": "[2, 3, 3]",
        "isHidden": false
      },
      {
        "input": "arr = [5, 5, 5, 5], k = 2",
        "expectedOutput": "[1, 1, 1]",
        "isHidden": false
      },
      {
        "input": "arr = [1, 2, 3, 4, 5], k = 5",
        "expectedOutput": "[5]",
        "isHidden": true
      },
      {
        "input": "arr = [1], k = 1",
        "expectedOutput": "[1]",
        "isHidden": true
      },
      {
        "input": "arr = [1, 1, 1, 1, 1, 1], k = 3",
        "expectedOutput": "[1, 1, 1, 1]",
        "isHidden": true
      }
    ],
    "order": 1,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a hash map to track frequency of elements in the current window",
      "When sliding the window, decrement frequency of the left element and increment frequency of the new right element"
    ],
    "tags": ["arrays", "sliding-window", "hashing"]
  },
  {
    "title": "Find peak element in mountain array",
    "topic": "Arrays",
    "difficulty": "Medium",
    "description": "A mountain array is defined as an array that first increases to a peak and then decreases. Given a mountain array, find the index of the peak element. The peak element is greater than both its neighbors. The array is guaranteed to have exactly one peak.\n\nNote: The first and last elements are not peaks.",
    "sampleInput": "arr = [1, 3, 5, 4, 2]",
    "sampleOutput": "2",
    "constraints": "3 ≤ n ≤ 10^5\n1 ≤ arr[i] ≤ 10^9\nArray is guaranteed to be a mountain array",
    "testCases": [
      {
        "input": "arr = [1, 3, 5, 4, 2]",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "arr = [1, 2, 3, 1]",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "arr = [1, 10, 5]",
        "expectedOutput": "1",
        "isHidden": true
      },
      {
        "input": "arr = [1, 2, 3, 4, 5, 4, 3, 2, 1]",
        "expectedOutput": "4",
        "isHidden": true
      },
      {
        "input": "arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2]",
        "expectedOutput": "0",
        "isHidden": true
      }
    ],
    "order": 2,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use binary search to find the peak",
      "Compare the middle element with its right neighbor to determine which side of the peak you're on"
    ],
    "tags": ["arrays", "binary-search"]
  },
  {
    "title": "Product of array except self",
    "topic": "Arrays",
    "difficulty": "Medium",
    "description": "Given an integer array, return an array where each element at index i is the product of all elements in the original array except the element at index i. You must solve this without using division and in O(n) time.\n\nExample: For [1, 2, 3, 4], output should be [24, 12, 8, 6].",
    "sampleInput": "arr = [1, 2, 3, 4]",
    "sampleOutput": "[24, 12, 8, 6]",
    "constraints": "2 ≤ n ≤ 10^5\n-30 ≤ arr[i] ≤ 30\nProduct of all elements fits in 32-bit integer",
    "testCases": [
      {
        "input": "arr = [1, 2, 3, 4]",
        "expectedOutput": "[24, 12, 8, 6]",
        "isHidden": false
      },
      {
        "input": "arr = [-1, 1, 0, -3, 3]",
        "expectedOutput": "[0, 0, 9, 0, 0]",
        "isHidden": false
      },
      {
        "input": "arr = [2, 3]",
        "expectedOutput": "[3, 2]",
        "isHidden": true
      },
      {
        "input": "arr = [1, 0, 0, 0]",
        "expectedOutput": "[0, 0, 0, 0]",
        "isHidden": true
      },
      {
        "input": "arr = [5, 2, 1, 4, 3]",
        "expectedOutput": "[24, 60, 120, 30, 40]",
        "isHidden": true
      }
    ],
    "order": 3,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use two passes: one from left to right to compute products of all elements to the left, then from right to left for products to the right",
      "You can combine both passes into a single result array"
    ],
    "tags": ["arrays", "prefix-sum"]
  },
  {
    "title": "Longest substring with at most k distinct characters",
    "topic": "Strings",
    "difficulty": "Medium",
    "description": "Given a string and an integer k, find the length of the longest substring that contains at most k distinct characters. If k is 0, return 0.\n\nExample: For string \"eceba\" and k=2, the longest substring is \"ece\" with length 3.",
    "sampleInput": "s = \"eceba\", k = 2",
    "sampleOutput": "3",
    "constraints": "1 ≤ n ≤ 10^5\n0 ≤ k ≤ 26\nString contains only lowercase English letters",
    "testCases": [
      {
        "input": "s = \"eceba\", k = 2",
        "expectedOutput": "3",
        "isHidden": false
      },
      {
        "input": "s = \"aa\", k = 1",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "s = \"abcabcabc\", k = 3",
        "expectedOutput": "9",
        "isHidden": true
      },
      {
        "input": "s = \"a\", k = 0",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "s = \"abcdefghijklmnopqrstuvwxyz\", k = 5",
        "expectedOutput": "5",
        "isHidden": true
      }
    ],
    "order": 4,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use sliding window technique with a hash map to track character frequencies",
      "When the window has more than k distinct characters, shrink it from the left"
    ],
    "tags": ["strings", "sliding-window", "hashing"]
  },
  {
    "title": "Minimum window substring",
    "topic": "Strings",
    "difficulty": "Hard",
    "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If no such window exists, return an empty string.\n\nExample: For s=\"ADOBECODEBANC\" and t=\"ABC\", the minimum window is \"BANC\".",
    "sampleInput": "s = \"ADOBECODEBANC\", t = \"ABC\"",
    "sampleOutput": "BANC",
    "constraints": "1 ≤ |s|, |t| ≤ 10^4\ns and t consist of uppercase and lowercase English letters",
    "testCases": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "expectedOutput": "BANC",
        "isHidden": false
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "expectedOutput": "a",
        "isHidden": false
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "expectedOutput": "(empty string)",
        "isHidden": true
      },
      {
        "input": "s = \"ab\", t = \"b\"",
        "expectedOutput": "b",
        "isHidden": true
      },
      {
        "input": "s = \"bba\", t = \"ab\"",
        "expectedOutput": "ba",
        "isHidden": true
      }
    ],
    "order": 5,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use sliding window with two pointers",
      "Maintain a frequency map for characters in t and track how many characters from t are currently satisfied in the window"
    ],
    "tags": ["strings", "sliding-window", "hashing", "two-pointers"]
  },
  {
    "title": "Group anagrams",
    "topic": "Strings",
    "difficulty": "Medium",
    "description": "Given an array of strings, group the anagrams together. An anagram is a word formed by rearranging the letters of another word. You can return the answer in any order.\n\nExample: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] should be grouped as [[\"eat\",\"tea\",\"ate\"], [\"tan\",\"nat\"], [\"bat\"]].",
    "sampleInput": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
    "sampleOutput": "[[\"eat\",\"tea\",\"ate\"], [\"tan\",\"nat\"], [\"bat\"]]",
    "constraints": "1 ≤ strs.length ≤ 10^4\n0 ≤ strs[i].length ≤ 100\nstrs[i] consists of lowercase English letters",
    "testCases": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "expectedOutput": "[[\"eat\",\"tea\",\"ate\"], [\"tan\",\"nat\"], [\"bat\"]]",
        "isHidden": false
      },
      {
        "input": "strs = [\"\"]",
        "expectedOutput": "[[\"\"]]",
        "isHidden": false
      },
      {
        "input": "strs = [\"a\"]",
        "expectedOutput": "[[\"a\"]]",
        "isHidden": true
      },
      {
        "input": "strs = [\"abc\", \"cba\", \"bac\", \"xyz\", \"zyx\"]",
        "expectedOutput": "[[\"abc\",\"cba\",\"bac\"], [\"xyz\",\"zyx\"]]",
        "isHidden": true
      },
      {
        "input": "strs = [\"a\", \"a\", \"a\"]",
        "expectedOutput": "[[\"a\",\"a\",\"a\"]]",
        "isHidden": true
      }
    ],
    "order": 6,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use the sorted version of each string as a key in a hash map",
      "Alternatively, use character frequency counts as the key"
    ],
    "tags": ["strings", "hashing", "sorting"]
  },
  {
    "title": "Longest palindromic substring",
    "topic": "Strings",
    "difficulty": "Medium",
    "description": "Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same backward as forward.\n\nExample: For \"babad\", one possible answer is \"bab\" or \"aba\".",
    "sampleInput": "s = \"babad\"",
    "sampleOutput": "bab",
    "constraints": "1 ≤ s.length ≤ 1000\ns consists of only digits and English letters",
    "testCases": [
      {
        "input": "s = \"babad\"",
        "expectedOutput": "bab",
        "isHidden": false
      },
      {
        "input": "s = \"cbbd\"",
        "expectedOutput": "bb",
        "isHidden": false
      },
      {
        "input": "s = \"a\"",
        "expectedOutput": "a",
        "isHidden": true
      },
      {
        "input": "s = \"ac\"",
        "expectedOutput": "a",
        "isHidden": true
      },
      {
        "input": "s = \"racecar\"",
        "expectedOutput": "racecar",
        "isHidden": true
      }
    ],
    "order": 7,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Expand around each center (both odd and even length palindromes)",
      "For each position, expand outward to find the longest palindrome centered at that position"
    ],
    "tags": ["strings", "dynamic-programming", "two-pointers"]
  },
  {
    "title": "First unique character in string",
    "topic": "Hashing",
    "difficulty": "Easy",
    "description": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. A character is non-repeating if it appears exactly once in the string.\n\nExample: For \"leetcode\", the first unique character is 'l' at index 0.",
    "sampleInput": "s = \"leetcode\"",
    "sampleOutput": "0",
    "constraints": "1 ≤ s.length ≤ 10^5\ns consists of only lowercase English letters",
    "testCases": [
      {
        "input": "s = \"leetcode\"",
        "expectedOutput": "0",
        "isHidden": false
      },
      {
        "input": "s = \"loveleetcode\"",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "s = \"aabb\"",
        "expectedOutput": "-1",
        "isHidden": true
      },
      {
        "input": "s = \"a\"",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "s = \"abccba\"",
        "expectedOutput": "-1",
        "isHidden": true
      }
    ],
    "order": 8,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a hash map to count frequency of each character",
      "Then iterate through the string again to find the first character with frequency 1"
    ],
    "tags": ["hashing", "strings"]
  },
  {
    "title": "Two sum with multiple solutions",
    "topic": "Hashing",
    "difficulty": "Easy",
    "description": "Given an array of integers and a target sum, find all unique pairs of indices (i, j) where i < j and arr[i] + arr[j] = target. Return the list of pairs.\n\nExample: For arr=[2,7,11,15] and target=9, return [[0,1]].",
    "sampleInput": "arr = [2,7,11,15], target = 9",
    "sampleOutput": "[[0,1]]",
    "constraints": "2 ≤ n ≤ 10^4\n-10^9 ≤ arr[i] ≤ 10^9\n-10^9 ≤ target ≤ 10^9",
    "testCases": [
      {
        "input": "arr = [2,7,11,15], target = 9",
        "expectedOutput": "[[0,1]]",
        "isHidden": false
      },
      {
        "input": "arr = [3,2,4], target = 6",
        "expectedOutput": "[[1,2]]",
        "isHidden": false
      },
      {
        "input": "arr = [1,1,1,1], target = 2",
        "expectedOutput": "[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]",
        "isHidden": true
      },
      {
        "input": "arr = [1,2,3], target = 10",
        "expectedOutput": "[]",
        "isHidden": true
      },
      {
        "input": "arr = [-1,0,1], target = 0",
        "expectedOutput": "[[0,2]]",
        "isHidden": true
      }
    ],
    "order": 9,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a hash map to store each number and its index as you iterate",
      "For each element, check if (target - current_element) exists in the map"
    ],
    "tags": ["hashing", "arrays"]
  },
  {
    "title": "Longest consecutive sequence",
    "topic": "Hashing",
    "difficulty": "Hard",
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. The algorithm should run in O(n) time.\n\nExample: For [100,4,200,1,3,2], the longest consecutive sequence is [1,2,3,4] with length 4.",
    "sampleInput": "arr = [100,4,200,1,3,2]",
    "sampleOutput": "4",
    "constraints": "0 ≤ n ≤ 10^5\n-10^9 ≤ arr[i] ≤ 10^9",
    "testCases": [
      {
        "input": "arr = [100,4,200,1,3,2]",
        "expectedOutput": "4",
        "isHidden": false
      },
      {
        "input": "arr = [0,3,7,2,5,8,4,6,0,1]",
        "expectedOutput": "9",
        "isHidden": false
      },
      {
        "input": "arr = []",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "arr = [1]",
        "expectedOutput": "1",
        "isHidden": true
      },
      {
        "input": "arr = [5,4,3,2,1]",
        "expectedOutput": "5",
        "isHidden": true
      }
    ],
    "order": 10,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a hash set to store all numbers for O(1) lookup",
      "For each number, check if it's the start of a sequence (number-1 doesn't exist), then expand forward"
    ],
    "tags": ["hashing", "arrays"]
  },
  {
    "title": "Subarray sum equals k",
    "topic": "Hashing",
    "difficulty": "Medium",
    "description": "Given an array of integers and an integer k, return the total number of continuous subarrays whose sum equals k.\n\nExample: For arr=[1,1,1] and k=2, there are 2 subarrays: [1,1] and [1,1] (overlapping).",
    "sampleInput": "arr = [1,1,1], k = 2",
    "sampleOutput": "2",
    "constraints": "1 ≤ n ≤ 2×10^4\n-1000 ≤ arr[i] ≤ 1000\n-10^7 ≤ k ≤ 10^7",
    "testCases": [
      {
        "input": "arr = [1,1,1], k = 2",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "arr = [1,2,3], k = 3",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "arr = [1], k = 0",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "arr = [-1,-1,1], k = 0",
        "expectedOutput": "1",
        "isHidden": true
      },
      {
        "input": "arr = [0,0,0,0,0,0,0,0,0,0], k = 0",
        "expectedOutput": "55",
        "isHidden": true
      }
    ],
    "order": 11,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use prefix sum and hash map",
      "For each prefix sum, check if (prefix_sum - k) exists in the map"
    ],
    "tags": ["hashing", "arrays", "prefix-sum"]
  },
  {
    "title": "Container with most water",
    "topic": "Two Pointers",
    "difficulty": "Medium",
    "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.\n\nExample: For height=[1,8,6,2,5,4,8,3,7], the maximum area is 49.",
    "sampleInput": "height = [1,8,6,2,5,4,8,3,7]",
    "sampleOutput": "49",
    "constraints": "n == height.length\n2 ≤ n ≤ 10^5\n0 ≤ height[i] ≤ 10^4",
    "testCases": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "expectedOutput": "49",
        "isHidden": false
      },
      {
        "input": "height = [1,1]",
        "expectedOutput": "1",
        "isHidden": false
      },
      {
        "input": "height = [1,2,1]",
        "expectedOutput": "2",
        "isHidden": true
      },
      {
        "input": "height = [5,4,3,2,1]",
        "expectedOutput": "6",
        "isHidden": true
      },
      {
        "input": "height = [10,1,1,10]",
        "expectedOutput": "30",
        "isHidden": true
      }
    ],
    "order": 12,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use two pointers starting from both ends",
      "Move the pointer with the smaller height, as moving the larger one cannot increase the area"
    ],
    "tags": ["two-pointers", "arrays", "greedy"]
  },
  {
    "title": "Trapping rain water",
    "topic": "Two Pointers",
    "difficulty": "Hard",
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nExample: For height=[0,1,0,2,1,0,1,3,2,1,2,1], the trapped water is 6 units.",
    "sampleInput": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
    "sampleOutput": "6",
    "constraints": "n == height.length\n1 ≤ n ≤ 2×10^4\n0 ≤ height[i] ≤ 10^5",
    "testCases": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "expectedOutput": "6",
        "isHidden": false
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "expectedOutput": "9",
        "isHidden": false
      },
      {
        "input": "height = [0,0,0,0]",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "height = [5,4,3,2,1]",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "height = [1,2,3,4,5]",
        "expectedOutput": "0",
        "isHidden": true
      }
    ],
    "order": 13,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use two pointers approach with left and right max heights",
      "Water trapped at position i is min(leftMax[i], rightMax[i]) - height[i]"
    ],
    "tags": ["two-pointers", "arrays", "dynamic-programming"]
  },
  {
    "title": "Three sum closest",
    "topic": "Two Pointers",
    "difficulty": "Medium",
    "description": "Given an integer array and a target value, find three integers in the array such that the sum is closest to the target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\nExample: For nums=[-1,2,1,-4] and target=1, the sum closest to target is 2 (from -1+2+1).",
    "sampleInput": "nums = [-1,2,1,-4], target = 1",
    "sampleOutput": "2",
    "constraints": "3 ≤ n ≤ 10^3\n-10^4 ≤ nums[i] ≤ 10^4\n-10^4 ≤ target ≤ 10^4",
    "testCases": [
      {
        "input": "nums = [-1,2,1,-4], target = 1",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "nums = [0,0,0], target = 1",
        "expectedOutput": "0",
        "isHidden": false
      },
      {
        "input": "nums = [1,1,1,1], target = 0",
        "expectedOutput": "3",
        "isHidden": true
      },
      {
        "input": "nums = [-1,0,1,2,-1,-4], target = 0",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "nums = [1,2,4,8,16,32,64,128], target = 82",
        "expectedOutput": "82",
        "isHidden": true
      }
    ],
    "order": 14,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Sort the array first",
      "Fix one element and use two pointers for the remaining two"
    ],
    "tags": ["two-pointers", "arrays", "sorting"]
  },
  {
    "title": "Maximum average subarray",
    "topic": "Sliding Window",
    "difficulty": "Easy",
    "description": "Given an integer array and an integer k, find a contiguous subarray of length k that has the maximum average value and return this maximum average value.\n\nExample: For nums=[1,12,-5,-6,50,3] and k=4, the maximum average is 12.75 (from subarray [12,-5,-6,50]).",
    "sampleInput": "nums = [1,12,-5,-6,50,3], k = 4",
    "sampleOutput": "12.75",
    "constraints": "1 ≤ k ≤ n ≤ 10^5\n-10^4 ≤ nums[i] ≤ 10^4",
    "testCases": [
      {
        "input": "nums = [1,12,-5,-6,50,3], k = 4",
        "expectedOutput": "12.75",
        "isHidden": false
      },
      {
        "input": "nums = [5], k = 1",
        "expectedOutput": "5.0",
        "isHidden": false
      },
      {
        "input": "nums = [1,2,3,4,5], k = 3",
        "expectedOutput": "4.0",
        "isHidden": true
      },
      {
        "input": "nums = [-1,-2,-3,-4,-5], k = 2",
        "expectedOutput": "-1.5",
        "isHidden": true
      },
      {
        "input": "nums = [0,4,0,3,2], k = 1",
        "expectedOutput": "4.0",
        "isHidden": true
      }
    ],
    "order": 15,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use sliding window of fixed size k",
      "Calculate sum of first window, then slide and update the sum"
    ],
    "tags": ["sliding-window", "arrays"]
  },
  {
    "title": "Valid parentheses",
    "topic": "Stack",
    "difficulty": "Easy",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: 1) Open brackets must be closed by the same type of brackets. 2) Open brackets must be closed in the correct order. 3) Every close bracket has a corresponding open bracket of the same type.\n\nExample: \"()\" is valid, \"([)]\" is not valid.",
    "sampleInput": "s = \"()\"",
    "sampleOutput": "true",
    "constraints": "1 ≤ s.length ≤ 10^4\ns consists of only '(', ')', '{', '}', '[' and ']'",
    "testCases": [
      {
        "input": "s = \"()\"",
        "expectedOutput": "true",
        "isHidden": false
      },
      {
        "input": "s = \"()[]{}\"",
        "expectedOutput": "true",
        "isHidden": false
      },
      {
        "input": "s = \"(]\"",
        "expectedOutput": "false",
        "isHidden": true
      },
      {
        "input": "s = \"([)]\"",
        "expectedOutput": "false",
        "isHidden": true
      },
      {
        "input": "s = \"{[]}\"",
        "expectedOutput": "true",
        "isHidden": true
      }
    ],
    "order": 16,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a stack to keep track of opening brackets",
      "When you encounter a closing bracket, check if it matches the top of the stack"
    ],
    "tags": ["stack", "strings"]
  },
  {
    "title": "Daily temperatures",
    "topic": "Stack",
    "difficulty": "Medium",
    "description": "Given an array of integers temperatures representing daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\nExample: For temperatures=[73,74,75,71,69,72,76,73], output is [1,1,4,2,1,1,0,0].",
    "sampleInput": "temperatures = [73,74,75,71,69,72,76,73]",
    "sampleOutput": "[1,1,4,2,1,1,0,0]",
    "constraints": "1 ≤ temperatures.length ≤ 10^5\n30 ≤ temperatures[i] ≤ 100",
    "testCases": [
      {
        "input": "temperatures = [73,74,75,71,69,72,76,73]",
        "expectedOutput": "[1,1,4,2,1,1,0,0]",
        "isHidden": false
      },
      {
        "input": "temperatures = [30,40,50,60]",
        "expectedOutput": "[1,1,1,0]",
        "isHidden": false
      },
      {
        "input": "temperatures = [30,60,90]",
        "expectedOutput": "[1,1,0]",
        "isHidden": true
      },
      {
        "input": "temperatures = [100,90,80,70]",
        "expectedOutput": "[0,0,0,0]",
        "isHidden": true
      },
      {
        "input": "temperatures = [50]",
        "expectedOutput": "[0]",
        "isHidden": true
      }
    ],
    "order": 17,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a monotonic stack to store indices",
      "When you find a warmer temperature, pop from stack and calculate the difference in indices"
    ],
    "tags": ["stack", "arrays", "monotonic-stack"]
  },
  {
    "title": "Largest rectangle in histogram",
    "topic": "Stack",
    "difficulty": "Hard",
    "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nExample: For heights=[2,1,5,6,2,3], the largest rectangle has area 10 (from bars at indices 2 and 3).",
    "sampleInput": "heights = [2,1,5,6,2,3]",
    "sampleOutput": "10",
    "constraints": "1 ≤ heights.length ≤ 10^5\n0 ≤ heights[i] ≤ 10^4",
    "testCases": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "expectedOutput": "10",
        "isHidden": false
      },
      {
        "input": "heights = [2,4]",
        "expectedOutput": "4",
        "isHidden": false
      },
      {
        "input": "heights = [1]",
        "expectedOutput": "1",
        "isHidden": true
      },
      {
        "input": "heights = [5,4,3,2,1]",
        "expectedOutput": "9",
        "isHidden": true
      },
      {
        "input": "heights = [1,2,3,4,5]",
        "expectedOutput": "9",
        "isHidden": true
      }
    ],
    "order": 18,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a stack to maintain indices of bars in increasing order of height",
      "When you encounter a bar shorter than the top of stack, calculate area using the popped bar as the minimum height"
    ],
    "tags": ["stack", "arrays", "monotonic-stack"]
  },
  {
    "title": "Design circular queue",
    "topic": "Queue",
    "difficulty": "Medium",
    "description": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle.\n\nImplement the CircularQueue class with methods: enQueue(value), deQueue(), Front(), Rear(), isEmpty(), isFull().",
    "sampleInput": "operations = [\"CircularQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"Rear\",\"isFull\",\"deQueue\",\"enQueue\",\"Rear\"]\nvalues = [[3],[1],[2],[3],[4],[],[],[],[4],[]]",
    "sampleOutput": "[null,true,true,true,false,4,true,true,true,4]",
    "constraints": "1 ≤ k ≤ 1000\n0 ≤ value ≤ 1000\nAt most 3000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull",
    "testCases": [
      {
        "input": "operations = [\"CircularQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"Rear\",\"isFull\",\"deQueue\",\"enQueue\",\"Rear\"]\nvalues = [[3],[1],[2],[3],[4],[],[],[],[4],[]]",
        "expectedOutput": "[null,true,true,true,false,4,true,true,true,4]",
        "isHidden": false
      },
      {
        "input": "operations = [\"CircularQueue\",\"enQueue\",\"Rear\",\"Front\",\"deQueue\",\"Front\",\"deQueue\",\"Front\",\"isEmpty\",\"isEmpty\",\"Rear\",\"Rear\"]\nvalues = [[3],[1],[],[],[],[],[],[],[],[],[],[]]",
        "expectedOutput": "[null,true,1,1,true,-1,true,-1,true,true,-1,-1]",
        "isHidden": false
      },
      {
        "input": "operations = [\"CircularQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"deQueue\",\"deQueue\",\"deQueue\",\"isEmpty\"]\nvalues = [[2],[1],[2],[3],[],[],[],[]]",
        "expectedOutput": "[null,true,true,false,true,true,true,true]",
        "isHidden": true
      },
      {
        "input": "operations = [\"CircularQueue\",\"enQueue\",\"Front\",\"Rear\",\"isEmpty\",\"isFull\"]\nvalues = [[1],[5],[],[],[],[]]",
        "expectedOutput": "[null,true,5,5,false,true]",
        "isHidden": true
      },
      {
        "input": "operations = [\"CircularQueue\",\"isEmpty\",\"isFull\",\"Front\",\"Rear\"]\nvalues = [[5],[],[],[],[]]",
        "expectedOutput": "[null,true,false,-1,-1]",
        "isHidden": true
      }
    ],
    "order": 19,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use an array of fixed size and two pointers: front and rear",
      "Use modulo arithmetic to wrap around when reaching the end of the array"
    ],
    "tags": ["queue", "design", "array"]
  },
  {
    "title": "Reverse linked list",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list's head.\n\nExample: For list 1->2->3->4->5, the reversed list is 5->4->3->2->1.",
    "sampleInput": "head = [1,2,3,4,5]",
    "sampleOutput": "[5,4,3,2,1]",
    "constraints": "The number of nodes in the list is in the range [0, 5000].\n-5000 ≤ Node.val ≤ 5000",
    "testCases": [
      {
        "input": "head = [1,2,3,4,5]",
        "expectedOutput": "[5,4,3,2,1]",
        "isHidden": false
      },
      {
        "input": "head = [1,2]",
        "expectedOutput": "[2,1]",
        "isHidden": false
      },
      {
        "input": "head = []",
        "expectedOutput": "[]",
        "isHidden": true
      },
      {
        "input": "head = [1]",
        "expectedOutput": "[1]",
        "isHidden": true
      },
      {
        "input": "head = [1,2,3,4,5,6,7,8,9,10]",
        "expectedOutput": "[10,9,8,7,6,5,4,3,2,1]",
        "isHidden": true
      }
    ],
    "order": 20,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use three pointers: prev, current, and next",
      "Iterate through the list, reversing the next pointer of each node"
    ],
    "tags": ["linked-list", "recursion"]
  },
  {
    "title": "Merge two sorted lists",
    "topic": "Linked List",
    "difficulty": "Easy",
    "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a sorted order. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.\n\nExample: For list1=[1,2,4] and list2=[1,3,4], the merged list is [1,1,2,3,4,4].",
    "sampleInput": "list1 = [1,2,4], list2 = [1,3,4]",
    "sampleOutput": "[1,1,2,3,4,4]",
    "constraints": "The number of nodes in both lists is in the range [0, 50].\n-100 ≤ Node.val ≤ 100\nBoth list1 and list2 are sorted in non-decreasing order",
    "testCases": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "expectedOutput": "[1,1,2,3,4,4]",
        "isHidden": false
      },
      {
        "input": "list1 = [], list2 = []",
        "expectedOutput": "[]",
        "isHidden": false
      },
      {
        "input": "list1 = [], list2 = [0]",
        "expectedOutput": "[0]",
        "isHidden": true
      },
      {
        "input": "list1 = [5], list2 = [1,2,4]",
        "expectedOutput": "[1,2,4,5]",
        "isHidden": true
      },
      {
        "input": "list1 = [1,3,5,7,9], list2 = [2,4,6,8,10]",
        "expectedOutput": "[1,2,3,4,5,6,7,8,9,10]",
        "isHidden": true
      }
    ],
    "order": 21,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use a dummy node to simplify edge cases",
      "Compare the values at the heads of both lists and attach the smaller one"
    ],
    "tags": ["linked-list", "recursion", "two-pointers"]
  },
  {
    "title": "Remove nth node from end",
    "topic": "Linked List",
    "difficulty": "Medium",
    "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nExample: For list [1,2,3,4,5] and n=2, remove node with value 4, resulting in [1,2,3,5].",
    "sampleInput": "head = [1,2,3,4,5], n = 2",
    "sampleOutput": "[1,2,3,5]",
    "constraints": "The number of nodes in the list is sz.\n1 ≤ sz ≤ 30\n0 ≤ n ≤ sz\n1 ≤ Node.val ≤ 100",
    "testCases": [
      {
        "input": "head = [1,2,3,4,5], n = 2",
        "expectedOutput": "[1,2,3,5]",
        "isHidden": false
      },
      {
        "input": "head = [1], n = 1",
        "expectedOutput": "[]",
        "isHidden": false
      },
      {
        "input": "head = [1,2], n = 1",
        "expectedOutput": "[1]",
        "isHidden": true
      },
      {
        "input": "head = [1,2,3,4,5], n = 5",
        "expectedOutput": "[2,3,4,5]",
        "isHidden": true
      },
      {
        "input": "head = [1,2,3,4,5,6,7,8,9,10], n = 7",
        "expectedOutput": "[1,2,3,5,6,7,8,9,10]",
        "isHidden": true
      }
    ],
    "order": 22,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use two pointers: move one pointer n steps ahead first",
      "Then move both pointers together until the fast pointer reaches the end"
    ],
    "tags": ["linked-list", "two-pointers"]
  },
  {
    "title": "Generate parentheses",
    "topic": "Recursion",
    "difficulty": "Medium",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nExample: For n=3, return [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"].",
    "sampleInput": "n = 3",
    "sampleOutput": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
    "constraints": "1 ≤ n ≤ 8",
    "testCases": [
      {
        "input": "n = 3",
        "expectedOutput": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
        "isHidden": false
      },
      {
        "input": "n = 1",
        "expectedOutput": "[\"()\"]",
        "isHidden": false
      },
      {
        "input": "n = 2",
        "expectedOutput": "[\"(())\",\"()()\"]",
        "isHidden": true
      },
      {
        "input": "n = 4",
        "expectedOutput": "[\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]",
        "isHidden": true
      },
      {
        "input": "n = 5",
        "expectedOutput": "[\"((((()))))\",\"(((()())))\",\"(((())()))\",\"(((()))())\",\"(((())))()\",\"((()(())))\",\"((()()()))\",\"((()())())\",\"((())(()))\",\"((())()())\",\"((()))(())\",\"((()))()()\",\"(()((())))\",\"(()(()()))\",\"(()(())())\",\"(()()(()))\",\"(()()()())\",\"(()())()()\",\"(())((()))\",\"(())(()())\",\"(())()(())\",\"(())()()()\",\"()(((())))\",\"()((()()))\",\"()((())())\",\"()((()))()\",\"()(()(()))\",\"()(()()())\",\"()(()())()\",\"()()((()))\",\"()()(()())\",\"()()(())()\",\"()()()(())\",\"()()()()()\"]",
        "isHidden": true
      }
    ],
    "order": 23,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use backtracking: add '(' when open < n and ')' when close < open",
      "Base case: when open == close == n, add the current string to result"
    ],
    "tags": ["recursion", "backtracking", "string"]
  },
  {
    "title": "Subset sum problem",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "description": "Given a set of positive integers and a target sum, determine if there exists a subset of the set that sums to the target. Return true if such a subset exists, false otherwise.\n\nExample: For set [3, 34, 4, 12, 5, 2] and target 9, return true (subset [4,5] sums to 9).",
    "sampleInput": "nums = [3, 34, 4, 12, 5, 2], target = 9",
    "sampleOutput": "true",
    "constraints": "1 ≤ n ≤ 20\n1 ≤ nums[i] ≤ 100\n1 ≤ target ≤ 1000",
    "testCases": [
      {
        "input": "nums = [3, 34, 4, 12, 5, 2], target = 9",
        "expectedOutput": "true",
        "isHidden": false
      },
      {
        "input": "nums = [1, 2, 3], target = 7",
        "expectedOutput": "false",
        "isHidden": false
      },
      {
        "input": "nums = [1], target = 1",
        "expectedOutput": "true",
        "isHidden": true
      },
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 15",
        "expectedOutput": "true",
        "isHidden": true
      },
      {
        "input": "nums = [10, 20, 30], target = 5",
        "expectedOutput": "false",
        "isHidden": true
      }
    ],
    "order": 24,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use backtracking: for each element, either include it or exclude it",
      "Use memoization to avoid recalculating the same subproblems"
    ],
    "tags": ["backtracking", "recursion", "dynamic-programming"]
  },
  {
    "title": "N-Queens problem",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "description": "The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n\nExample: For n=4, there are 2 solutions.",
    "sampleInput": "n = 4",
    "sampleOutput": "2",
    "constraints": "1 ≤ n ≤ 9",
    "testCases": [
      {
        "input": "n = 4",
        "expectedOutput": "2",
        "isHidden": false
      },
      {
        "input": "n = 1",
        "expectedOutput": "1",
        "isHidden": false
      },
      {
        "input": "n = 2",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "n = 3",
        "expectedOutput": "0",
        "isHidden": true
      },
      {
        "input": "n = 8",
        "expectedOutput": "92",
        "isHidden": true
      }
    ],
    "order": 25,
    "starterCode": {
      "java": "public class Main {\n    public static void main(String[] args) {\n        // TODO: Implement your solution here\n    }\n}",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // TODO: Implement your solution here\n    return 0;\n}",
      "python": "def solve():\n    # TODO: Implement your solution here\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()",
      "javascript": "function solve() {\n  // TODO: Implement your solution here\n}\n\nsolve();"
    },
    "hints": [
      "Use backtracking: place queens row by row",
      "Check if placing a queen at (row, col) conflicts with previously placed queens (same column, same diagonal)"
    ],
    "tags": ["backtracking", "recursion"]
  }
]

